{
    "patches": [
        {
            "label": "2025-06-08_20-13-33",
            "content": "@@ -32,39 +32,8 @@\n ybe%0A\n-import Data.Char (ord, chr)%0A%0A%7B-\n %0A-- \n@@ -1160,588 +1160,8 @@\n  ...\n-%0A-%7D%0A%0Anext c = chr (ord c + 1)%0A%0AmodifyStr str i ch = ini ++ %5Bch%5D ++ end%0A    where%0A        ini = take i str%0A        end = drop (i+1) str%0A%0AgetInfSupLim lim i len = %5Bx %7C x %3C- %5B-lim..lim%5D, 0 %3C= (i+x) && (i+x) %3C len%5D%0A%0AcanBePlaced str i el lim len = null %5Bx %7C x %3C- getInfSupLim lim i len, str !! (i + x) == el%5D%0A%0Achange str i lim el%0A    %7C i %3E= length str = str%0A    %7C (str !! i) /= '.' = change str (i+1) lim el%0A    %7C el %60notElem%60 %5B'0'..'9'%5D = str%0A    %7C otherwise = if (canBePlaced str i el lim (length str)) then (change (modifyStr str i el) (i+1) lim '0') else change str i lim (next el)\n %0A%0Ama\n@@ -1247,27 +1247,25 @@\n n $ \n-change\n+mainSolver\n  xs \n-0 \n lim\n- '0'\n %0A%0A%0A-\n"
        },
        {
            "label": "2025-06-08_20-14-42",
            "content": "@@ -2117,18 +2117,16 @@\n -------%0A\n-%7B-\n %0A%0AneibTe\n@@ -3602,10 +3602,8 @@\n 874620%22%0A\n--%7D\n"
        },
        {
            "label": "2025-06-08_20-15-06",
            "content": "@@ -13,15 +13,8 @@\n List\n- (elem)\n %0Aimp\n@@ -31,22 +31,8 @@\n aybe\n- (listToMaybe)\n %0Aimp\n@@ -50,18 +50,21 @@\n ar (\n-chr, ord)%0A\n+ord, chr)%0A%0A%7B-\n %0A-- \n@@ -213,140 +213,12 @@\n im =\n-%0A    let start = max 0 (index - lim)%0A        end   = min (length xs - 1) (index + lim)%0A    in take (end - start + 1) (drop start xs)\n+ ...\n %0A%0A--\n@@ -307,19 +307,11 @@\n s = \n-y %60elem%60 xs\n+...\n %0A%0A--\n@@ -352,19 +352,42 @@\n char :: \n-Int\n+(Eq a, Num a, Enum a) =%3E a\n  -%3E Char\n@@ -406,27 +406,11 @@\n g = \n-chr (ord '0' + dig)\n+...\n %0A%0A--\n@@ -487,16 +487,17 @@\n  Int) -%3E\n+ \n  Int -%3E \n@@ -539,99 +539,12 @@\n ue =\n-%0A    let window = neib xs index lim%0A        c = dig2char value%0A    in not (exists c window)\n+ ...\n %0A%0A--\n@@ -621,46 +621,11 @@\n s = \n-%5Bi %7C (c, i) %3C- zip xs %5B0..%5D, c == '.'%5D\n+...\n %0A%0A--\n@@ -751,88 +751,12 @@\n ue =\n-%0A    let (pre, _:post) = splitAt index xs%0A    in pre ++ %5Bdig2char value%5D ++ post\n+ ...\n %0A%0A--\n@@ -868,880 +868,1264 @@\n ing%0A\n-solve :: (String, Int) -%3E %5BInt%5D -%3E Int -%3E Maybe String%0Asolve (xs, lim) holes hindex%0A    %7C hindex %3E= length holes = Just xs%0A    %7C otherwise =%0A        let index = holes !! hindex%0A            tryValues = %5B0..lim%5D%0A        in listToMaybe $ do%0A            v %3C- tryValues%0A            if fit (xs, lim) index v%0A               then case solve (set xs index v, lim) holes (hindex + 1) of%0A                      Just res -%3E return res%0A                      Nothing  -%3E %5B%5D%0A               else %5B%5D%0A%0A-- prepara a entrada para a fun%C3%A7%C3%A3o recursiva de resolu%C3%A7%C3%A3o%0AmainSolver :: String -%3E Int -%3E String%0AmainSolver xs lim =%0A    let holes = getHoles xs%0A    in case solve (xs, lim) holes 0 of%0A         Just result -%3E result%0A         Nothing     -%3E error %22No solution found%22%0A%0Amain :: IO ()%0Amain = do%0A    xs %3C- getLine%0A    lim %3C- readLn :: IO Int%0A    putStrLn $ mainSolver xs lim%0A%0A-- Testes auxiliares\n+-- problema (xs, lim)%0A-- holes: lista de posi%C3%A7%C3%B5es a serem preenchidas%0A-- hindex: posicao atual no vetor de holes%0Asolve :: (String, Int) -%3E %5BInt%5D -%3E Int -%3E Maybe String%0Asolve (xs, lim) holes hindex = ...%0A%0A-- prepara a entrada para a fun%C3%A7%C3%A3o recursiva de resolu%C3%A7%C3%A3o%0AmainSolver :: String -%3E Int -%3E String%0AmainSolver xs lim = ...%0A-%7D%0A%0Anext c = chr (ord c + 1)%0A%0AmodifyStr str i ch = ini ++ %5Bch%5D ++ end%0A    where%0A        ini = take i str%0A        end = drop (i+1) str%0A%0AgetInfSupLim lim i len = %5Bx %7C x %3C- %5B-lim..lim%5D, 0 %3C= (i+x) && (i+x) %3C len%5D%0A%0AcanBePlaced str i el lim len = null %5Bx %7C x %3C- getInfSupLim lim i len, str !! (i + x) == el%5D%0A%0Achange str i lim el%0A    %7C i %3E= length str = str%0A    %7C (str !! i) /= '.' = change str (i+1) lim el%0A    %7C el %60notElem%60 %5B'0'..'9'%5D = str%0A    %7C otherwise = if (canBePlaced str i el lim (length str)) then (change (modifyStr str i el) (i+1) lim '0') else change str i lim (next el)%0A%0Amain :: IO ()%0Amain = do%0A    xs %3C- getLine%0A    lim %3C- readLn :: IO Int%0A    putStrLn $ change xs 0 lim '0'%0A%0A%0A------------------------------------------------------------------------------------%0A-- Testes para lhe auxiliar a construir a solu%C3%A7%C3%A3o de forma mais segura%0A------------------------------------------------------------------------------------%0A%7B-%0A\n %0Anei\n@@ -2620,32 +2620,139 @@\n  ()%0AfitTest = do\n+ -- (fit (%2212.345%22, 1) 2) se torna uma fun%C3%A7%C3%A3o curry faltando s%C3%B3 uma var que seria o valor recebido do vetor\n %0A    print $ map\n@@ -3600,12 +3600,14 @@\n 9531874620%22%0A\n+-%7D\n"
        },
        {
            "label": "2025-06-08_20-34-33",
            "content": "import Data.List (elem)\nimport Data.Maybe (listToMaybe)\nimport Data.Char (chr, ord)\n\n-- retorna o subvetor incluindo o elemento posi\u00e7\u00e3o \u00edndice e lim elementos a esquerda e a direita\nneib :: [a] -> Int -> Int -> [a]\nneib xs index lim =\n    let start = max 0 (index - lim)\n        end   = min (length xs - 1) (index + lim)\n    in take (end - start + 1) (drop start xs)\n\n-- verifica se o valor existe no vetor\nexists :: Eq a => a -> [a] -> Bool\nexists y xs = y `elem` xs\n\n-- converte de digito para char\ndig2char :: Int -> Char\ndig2char dig = chr (ord '0' + dig)\n\n-- verifica se esse valor pode ser inserido nesse \u00edndice\nfit :: (String, Int) -> Int -> Int -> Bool\nfit (xs, lim) index value =\n    let window = neib xs index lim\n        c = dig2char value\n    in not (exists c window)\n\n-- pega as posi\u00e7\u00f5es de todos os .\ngetHoles :: String -> [Int]\ngetHoles xs = [i | (c, i) <- zip xs [0..], c == '.']\n\n-- insere esse valor nesse index e retorna o novo vetor resultante\nset :: String -> Int -> Int -> String\nset xs index value =\n    let (pre, _:post) = splitAt index xs\n    in pre ++ [dig2char value] ++ post\n\n-- tenta resolver o problema para essa posi\u00e7\u00e3o\n-- se \u00e9 poss\u00edvel resolver, retorna Just resposta, sen\u00e3o Nothing\nsolve :: (String, Int) -> [Int] -> Int -> Maybe String\nsolve (xs, lim) holes hindex\n    | hindex >= length holes = Just xs\n    | otherwise =\n        let index = holes !! hindex\n            tryValues = [0..lim]\n        in listToMaybe $ do\n            v <- tryValues\n            if fit (xs, lim) index v\n               then case solve (set xs index v, lim) holes (hindex + 1) of\n                      Just res -> return res\n                      Nothing  -> []\n               else []\n\n-- prepara a entrada para a fun\u00e7\u00e3o recursiva de resolu\u00e7\u00e3o\nmainSolver :: String -> Int -> String\nmainSolver xs lim =\n    let holes = getHoles xs\n    in case solve (xs, lim) holes 0 of\n         Just result -> result\n         Nothing     -> error \"No solution found\"\n\nmain :: IO ()\nmain = do\n    xs <- getLine\n    lim <- readLn :: IO Int\n    putStrLn $ mainSolver xs lim\n\n-- Testes auxiliares\nneibTest :: IO ()\nneibTest = do\n    print $ neib \"abcdef..\" 0 2 == \"abc\"\n    print $ neib \"abc.def\"  3 1 == \"c.d\"\n    print $ neib \"abc.def\"  3 2 == \"bc.de\"\n    print $ neib \"abc.def\"  1 2 == \"abc.\"\n    print $ neib \"abc.def\"  5 3 == \"c.def\"\n\ndig2charTest :: IO ()\ndig2charTest = do\n    print $ map dig2char [0..9] == ['0'..'9']\n\nsetTest :: IO ()\nsetTest = do\n    print $ set \"12345\" 0 9 == \"92345\"\n    print $ set \"12345\" 1 9 == \"19345\"\n    print $ set \"12345\" 4 9 == \"12349\"\n\nfitTest :: IO ()\nfitTest = do\n    print $ map (fit (\"12.345\", 1) 2) [1,2,3,4,5] == [True, False, False, True, True]\n    print $ map (fit (\"12.345\", 2) 2) [1,2,3,4,5] == [False, False, False, False, True]\n    print $ map (fit (\"12.345\", 3) 2) [1,2,3,4,5] == [False, False, False, False, False]\n    print $ map (fit (\"12345.\", 4) 5) [1,2,3,4,5] == [True, False, False, False, False]\n\ngetHolesTest :: IO ()\ngetHolesTest = do\n    print $ getHoles \"12.3..\" == [2,4,5]\n    print $ getHoles \"12.3.4\" == [2,4]\n    print $ getHoles \"...3.4\" == [0,1,2,4]\n\nmainTest :: IO ()\nmainTest = do\n    print $ mainSolver \"01.2.\" 3 == \"01320\"\n    print $ mainSolver \".0..231..5\" 5 == \"1045231045\"\n    print $ mainSolver \"2..0..............3...........\" 3 == \"213021302130213021302130213021\"\n    print $ mainSolver \"0..32..41.\" 5 == \"0413250413\"\n    print $ mainSolver \"9....7.620.5318.....\" 9 == \"95318746209531874620\"\n"
        }
    ]
}